<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>XZ 粒子超感系统 - 30K Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #info {
            position: absolute; top: 20px; left: 20px; color: #fff;
            font-family: 'Segoe UI', sans-serif; pointer-events: none;
            z-index: 10; text-shadow: 0 0 10px rgba(0,255,255,0.8);
        }
        video { transform: scaleX(-1); position: absolute; bottom: 10px; right: 10px; width: 150px; border-radius: 8px; border: 1px solid #333; }
        canvas { filter: contrast(1.2) brightness(1.1); }
    </style>
</head>
<body>
    <div id="info">
        <h2 style="margin:0">XZ 粒子交互系统</h2>
        <p>粒子数: 30,000 | 状态: 实时响应</p>
        <b>左手控制：</b>1/2/3指切换文字 | 捏合缩放<br>
        <b>右手交互：</b>穿梭粒子群产生物理扰动
    </div>
    <video id="input_video"></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const videoElement = document.getElementById('input_video');
        const pCount = 30000; // 粒子数提升至 3万
        let scene, camera, renderer, particles, geometry;
        let targetPoints = [];
        let curScale = 1;
        let disturbPoint = new THREE.Vector3(1000, 1000, 1000);

        // --- 文字采样优化：支持高密度 ---
        function createTextPoints(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 600; canvas.height = 300;
            ctx.fillStyle = 'white';
            ctx.font = 'bold 60px "Microsoft YaHei"';
            ctx.textAlign = 'center';
            ctx.fillText(text, 300, 150);

            const data = ctx.getImageData(0, 0, 600, 300).data;
            const pts = [];
            // 采样主点
            for (let y = 0; y < 300; y += 2) {
                for (let x = 0; x < 600; x += 2) {
                    if (data[(y * 600 + x) * 4 + 3] > 128) {
                        pts.push(new THREE.Vector3((x - 300) * 0.04, (150 - y) * 0.04, 0));
                    }
                }
            }
            
            const finalPts = [];
            for (let i = 0; i < pCount; i++) {
                // 如果采样点不足，则在已有采样点周围随机分布，增加厚度感
                const source = pts[i % pts.length];
                const p = source.clone();
                if (i >= pts.length) {
                    p.x += (Math.random() - 0.5) * 0.5;
                    p.y += (Math.random() - 0.5) * 0.5;
                    p.z += (Math.random() - 0.5) * 0.5;
                }
                finalPts.push(p);
            }
            return finalPts;
        }

        const library = {
            1: createTextPoints("Hello"),
            2: createTextPoints("我是 XZ"),
            3: createTextPoints("今晚夜宵吃什么")
        };
        targetPoints = library[1];

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 18;

            renderer = new THREE.WebGLRenderer({ antialias: false }); // 粒子多时关闭抗锯齿提升性能
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            geometry = new THREE.BufferGeometry();
            const posArray = new Float32Array(pCount * 3);
            const colorArray = new Float32Array(pCount * 3);
            
            for(let i=0; i<pCount; i++) {
                posArray[i*3] = (Math.random()-0.5)*40;
                posArray[i*3+1] = (Math.random()-0.5)*40;
                posArray[i*3+2] = (Math.random()-0.5)*40;
                
                // 初始颜色：青色系
                colorArray[i*3] = 0; 
                colorArray[i*3+1] = 0.8; 
                colorArray[i*3+2] = 1.0;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
            
            const mat = new THREE.PointsMaterial({ 
                size: 0.04, 
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.6
            });

            particles = new THREE.Points(geometry, mat);
            scene.add(particles);
            loop();
        }

        function loop() {
            requestAnimationFrame(loop);
            const pos = geometry.attributes.position.array;
            const cols = geometry.attributes.color.array;
            
            for (let i = 0; i < pCount; i++) {
                const i3 = i * 3;
                const target = targetPoints[i];
                
                const destX = target.x * curScale;
                const destY = target.y * curScale;
                const destZ = target.z;

                // 物理计算
                let dx = pos[i3] - disturbPoint.x;
                let dy = pos[i3+1] - disturbPoint.y;
                let distSq = dx*dx + dy*dy;
                let forceRange = 9; 

                if (distSq < forceRange) {
                    let force = (forceRange - distSq) / forceRange;
                    pos[i3] += dx * force * 0.3;
                    pos[i3+1] += dy * force * 0.3;
                    // 扰动时变色（变为紫色）
                    cols[i3] = 0.8; cols[i3+1] = 0.2;
                } else {
                    // 恢复颜色
                    cols[i3] += (0 - cols[i3]) * 0.05;
                    cols[i3+1] += (0.8 - cols[i3+1]) * 0.05;
                }

                // 基础平滑回归
                pos[i3] += (destX - pos[i3]) * 0.06;
                pos[i3+1] += (destY - pos[i3+1]) * 0.06;
                pos[i3+2] += (destZ - pos[i3+2]) * 0.06;
            }
            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            
            // 场景轻微旋转增加动感
            particles.rotation.y += 0.002;
            
            renderer.render(scene, camera);
        }

        function onResults(results) {
            disturbPoint.set(1000, 1000, 1000);
            if (results.multiHandLandmarks) {
                results.multiHandLandmarks.forEach((landmarks, index) => {
                    const isRightHand = results.multiHandedness[index].label === 'Right';
                    const x = (0.5 - landmarks[8].x) * 35;
                    const y = (0.5 - landmarks[8].y) * 20;

                    if (!isRightHand) { // 左手逻辑：扰动
                        disturbPoint.set(x, y, 0);
                    } else { // 右手逻辑：控制文字和缩放
                        const check = (t, p) => landmarks[t].y < landmarks[p].y;
                        const count = [check(8,6), check(12,10), check(16,14)].filter(v=>v).length;
                        if (library[count]) targetPoints = library[count];

                        const d = Math.hypot(landmarks[8].x - landmarks[4].x, landmarks[8].y - landmarks[4].y);
                        curScale = THREE.MathUtils.mapLinear(d, 0.05, 0.3, 0.5, 4.0);
                    }
                });
            }
        }

        const hands = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5 });
        hands.onResults(onResults);

        new Camera(videoElement, {
            onFrame: async () => { await hands.send({ image: videoElement }); },
            width: 640, height: 480
        }).start();

        init();
        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>







