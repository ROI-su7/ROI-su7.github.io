<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>3D粒子手势交互 - XZ</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px; left: 10px;
            color: white;
            font-family: Arial;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
        }
        video { transform: scaleX(-1); position: absolute; bottom: 10px; right: 10px; width: 200px; border: 2px solid #555; }
    </style>
</head>
<body>
    <div id="info">手势 1: Hello | 手势 2: 我是 XZ | 手势 3: 今晚夜宵吃什么<br>张合双手控制扩散/收缩</div>
    <video id="input_video"></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const videoElement = document.getElementById('input_video');
        const particleCount = 5000;
        let scene, camera, renderer, particles, geometry;
        let targetPoints = [];
        let currentScale = 1;

        // 1. 文字采样函数
        function createTextPoints(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 400;
            canvas.height = 200;
            ctx.fillStyle = 'white';
            ctx.font = 'bold 40px "Microsoft YaHei", sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 200, 100);

            const imageData = ctx.getImageData(0, 0, 400, 200).data;
            const pts = [];
            for (let y = 0; y < 200; y += 2) {
                for (let x = 0; x < 400; x += 2) {
                    const alpha = imageData[(y * 400 + x) * 4 + 3];
                    if (alpha > 128) {
                        pts.push(new THREE.Vector3((x - 200) * 0.05, (100 - y) * 0.05, 0));
                    }
                }
            }
            // 补齐点数
            while (pts.length < particleCount) {
                pts.push(new THREE.Vector3((Math.random()-0.5)*20, (Math.random()-0.5)*20, (Math.random()-0.5)*20));
            }
            return pts;
        }

        const textLibrary = {
            1: createTextPoints("Hello"),
            2: createTextPoints("我是 XZ"),
            3: createTextPoints("今晚夜宵吃什么")
        };
        targetPoints = textLibrary[1];

        // 2. 初始化 Three.js
        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 15;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            for(let i=0; i<particleCount*3; i++) positions[i] = (Math.random() - 0.5) * 20;
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({ color: 0x00ffff, size: 0.08, transparent: true, opacity: 0.8 });
            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            const positions = geometry.attributes.position.array;
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const target = targetPoints[i];
                
                // 缓动动画：当前位置向 (目标点 * 缩放) 移动
                positions[i3] += (target.x * currentScale - positions[i3]) * 0.1;
                positions[i3+1] += (target.y * currentScale - positions[i3+1]) * 0.1;
                positions[i3+2] += (target.z * currentScale - positions[i3+2]) * 0.1;
            }
            geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        // 3. 手势识别逻辑
        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];

                // 识别数字手势 (根据手指尖是否高于指节)
                const checkUp = (tip, pip) => landmarks[tip].y < landmarks[pip].y;
                const fingers = [
                    checkUp(8, 6),  // 食指
                    checkUp(12, 10), // 中指
                    checkUp(16, 14), // 无名指
                    checkUp(20, 18)  // 小指
                ];

                const count = fingers.filter(v => v).length;
                if (textLibrary[count]) targetPoints = textLibrary[count];

                // 计算张合度 (食指尖到大拇指尖的距离)
                const dx = landmarks[8].x - landmarks[4].x;
                const dy = landmarks[8].y - landmarks[4].y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                // 映射距离到缩放 (0.1 - 0.4 映射到 0.5 - 3.0)
                currentScale = THREE.MathUtils.mapLinear(dist, 0.05, 0.3, 0.5, 3.0);
            }
        }

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => { await hands.send({ image: videoElement }); },
            width: 640, height: 480
        });

        initThree();
        cameraFeed.start();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>





