<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>XZ 粒子超感系统 - 80K Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #info {
            position: absolute; top: 20px; left: 20px; color: #fff;
            font-family: 'Segoe UI', sans-serif; pointer-events: none;
            z-index: 10; text-shadow: 0 0 10px rgba(0,255,255,0.8);
        }
        video { transform: scaleX(-1); position: absolute; bottom: 10px; right: 10px; width: 120px; border-radius: 5px; opacity: 0.5; }
    </style>
</head>
<body>
    <div id="info">
        <h2 style="margin:0">XZ 粒子交互系统 V2.0</h2>
        <p>粒子数: 80,000 | 超大字体模式</p>
    </div>
    <video id="input_video"></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const videoElement = document.getElementById('input_video');
        const pCount = 80000; // 粒子数提升
        let scene, camera, renderer, particles, geometry;
        let targetPoints = [];
        let curScale = 1.2; // 默认基础缩放调大
        let disturbPoint = new THREE.Vector3(1000, 1000, 1000);

        function createTextPoints(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            // 提高 Canvas 分辨率以支持大字体
            canvas.width = 1024; canvas.height = 512;
            ctx.fillStyle = 'white';
            // 字体大小直接翻倍
            ctx.font = 'bold 120px "Microsoft YaHei"';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 512, 256);

            const data = ctx.getImageData(0, 0, 1024, 512).data;
            const pts = [];
            for (let y = 0; y < 512; y += 2) {
                for (let x = 0; x < 1024; x += 2) {
                    if (data[(y * 1024 + x) * 4 + 3] > 128) {
                        // 调整这里的坐标映射系数，实现“物理放大”
                        pts.push(new THREE.Vector3((x - 512) * 0.05, (256 - y) * 0.05, 0));
                    }
                }
            }
            
            const finalPts = [];
            for (let i = 0; i < pCount; i++) {
                const source = pts[i % pts.length];
                const p = source.clone();
                if (i >= pts.length) {
                    // 增加随机散布，让文字边缘有“星尘”效果
                    p.x += (Math.random() - 0.5) * 0.8;
                    p.y += (Math.random() - 0.5) * 0.8;
                    p.z += (Math.random() - 0.5) * 0.8;
                }
                finalPts.push(p);
            }
            return finalPts;
        }

        const library = {
            1: createTextPoints("Hello"),
            2: createTextPoints("我是 XZ"),
            3: createTextPoints("今晚夜宵吃什么")
        };
        targetPoints = library[1];

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 25; // 镜头拉远一点以容纳更大的字体

            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(1); // 8万粒子建议固定像素比以保帧率
            document.body.appendChild(renderer.domElement);

            geometry = new THREE.BufferGeometry();
            const posArray = new Float32Array(pCount * 3);
            const colorArray = new Float32Array(pCount * 3);
            
            for(let i=0; i<pCount; i++) {
                posArray[i*3] = (Math.random()-0.5)*100;
                posArray[i*3+1] = (Math.random()-0.5)*100;
                posArray[i*3+2] = (Math.random()-0.5)*100;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
            
            const mat = new THREE.PointsMaterial({ 
                size: 0.025, // 粒子更细碎，效果更高级
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.7
            });

            particles = new THREE.Points(geometry, mat);
            scene.add(particles);
            loop();
        }

        function loop() {
            requestAnimationFrame(loop);
            const pos = geometry.attributes.position.array;
            const cols = geometry.attributes.color.array;
            const time = Date.now() * 0.001;
            
            for (let i = 0; i < pCount; i++) {
                const i3 = i * 3;
                const target = targetPoints[i];
                
                const destX = target.x * curScale;
                const destY = target.y * curScale;

                // 物理扰动
                let dx = pos[i3] - disturbPoint.x;
                let dy = pos[i3+1] - disturbPoint.y;
                let distSq = dx*dx + dy*dy;
                let forceRange = 12; // 增大影响范围

                if (distSq < forceRange) {
                    let force = (forceRange - distSq) / forceRange;
                    pos[i3] += dx * force * 0.4;
                    pos[i3+1] += dy * force * 0.4;
                    // 扰动变色：亮紫色
                    cols[i3] = 1.0; cols[i3+1] = 0.4; cols[i3+2] = 1.0;
                } else {
                    // 默认渐变色：蓝绿色系随时间微动
                    cols[i3] += (0.1 - cols[i3]) * 0.03;
                    cols[i3+1] += (0.7 + Math.sin(time + i*0.001)*0.2 - cols[i3+1]) * 0.03;
                    cols[i3+2] += (0.9 - cols[i3+2]) * 0.03;
                }

                pos[i3] += (destX - pos[i3]) * 0.07;
                pos[i3+1] += (destY - pos[i3+1]) * 0.07;
                pos[i3+2] += (target.z - pos[i3+2]) * 0.07;
            }
            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            
            particles.rotation.z = Math.sin(time * 0.2) * 0.05; // 增加轻微摆动感
            renderer.render(scene, camera);
        }

        function onResults(results) {
            disturbPoint.set(2000, 2000, 2000);
            if (results.multiHandLandmarks) {
                results.multiHandLandmarks.forEach((landmarks, index) => {
                    const label = results.multiHandedness[index].label; 
                    // 坐标映射适配大字体
                    const x = (0.5 - landmarks[8].x) * 45; 
                    const y = (0.5 - landmarks[8].y) * 25;

                    if (label === 'Left') { // 左手扰动
                        disturbPoint.set(x, y, 0);
                    } else { // 右手主控
                        const check = (t, p) => landmarks[t].y < landmarks[p].y;
                        const count = [check(8,6), check(12,10), check(16,14)].filter(v=>v).length;
                        if (library[count]) targetPoints = library[count];

                        const d = Math.hypot(landmarks[8].x - landmarks[4].x, landmarks[8].y - landmarks[4].y);
                        // 缩放范围也调大
                        curScale = THREE.MathUtils.mapLinear(d, 0.05, 0.35, 0.8, 5.0);
                    }
                });
            }
        }

        const hands = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5 });
        hands.onResults(onResults);

        new Camera(videoElement, {
            onFrame: async () => { await hands.send({ image: videoElement }); },
            width: 640, height: 480
        }).start();

        init();
        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>







