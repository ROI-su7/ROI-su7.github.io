<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>Merry Christmas</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

<meta property="og:title" content="ğŸ„ Merry Christmas">
<meta property="og:description" content="Toï¼šé©¬ä¸€æ–¹ï½œå¸Œæœ›ä½ æ¯å¤©å¼€å¿ƒï½">

<style>
body {
  margin: 0;
  overflow: hidden;
  background: black;
  font-family: -apple-system, BlinkMacSystemFont;
}

/* æ–‡æœ¬åŒºåŸŸ */
.text {
  position: absolute;
  right: 6%;
  top: 40%;
  color: white;
  z-index: 10;
}

.text h1 {
  font-size: 30px;
  margin-bottom: 12px;
  font-weight: 500;
}

#name span {
  opacity: 0;
  font-size: 22px;
  color: #fff;
  text-shadow: 0 0 10px #aaddff;
  animation: glow 1.2s forwards;
}

@keyframes glow {
  to {
    opacity: 1;
    text-shadow: 0 0 18px #ffffff;
  }
}
</style>
</head>
<body>

<div class="text">
  <h1>Merry Christmas</h1>
  <div id="name"></div>
  <p>å¸Œæœ›ä½ æ¯å¤©å¼€å¿ƒï½</p>
</div>

<!-- ğŸ¶ èƒŒæ™¯éŸ³ä¹ -->
<audio id="bgm" loop>
  <source src="https://cdn.pixabay.com/audio/2022/10/25/audio_946b4d14e5.mp3" type="audio/mpeg">
</audio>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

<script>
/* ========= å¾®ä¿¡è‡ªåŠ¨æ’­æ”¾éŸ³ä¹ ========= */
const audio = document.getElementById("bgm");
document.addEventListener("WeixinJSBridgeReady", () => {
  audio.play();
}, false);
document.body.addEventListener("click", () => audio.play(), { once: true });

/* ========= åå­—é€å­—å‘å…‰ ========= */
const name = "Toï¼šé©¬ä¸€æ–¹";
const nameDiv = document.getElementById("name");

[...name].forEach((char, i) => {
  const span = document.createElement("span");
  span.textContent = char;
  span.style.animationDelay = `${i * 0.3}s`;
  nameDiv.appendChild(span);
});

/* ========= Three.js åœºæ™¯ ========= */
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  60, window.innerWidth / window.innerHeight, 0.1, 1000
);
camera.position.z = 65;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* æ˜Ÿç©º */
const starsGeo = new THREE.BufferGeometry();
const starsPos = [];
for (let i = 0; i < 1200; i++) {
  starsPos.push(
    (Math.random() - 0.5) * 400,
    (Math.random() - 0.5) * 400,
    (Math.random() - 0.5) * 400
  );
}
starsGeo.setAttribute("position", new THREE.Float32BufferAttribute(starsPos, 3));
const stars = new THREE.Points(
  starsGeo,
  new THREE.PointsMaterial({ color: 0xffffff, size: 0.6 })
);
scene.add(stars);

/* åœ£è¯æ ‘ */
const treeGeo = new THREE.BufferGeometry();
const treePos = [];
for (let i = 0; i < 2500; i++) {
  const t = Math.random();
  const radius = (1 - t) * 18;
  const angle = Math.random() * Math.PI * 2;
  treePos.push(
    Math.cos(angle) * radius,
    t * 40 - 20,
    Math.sin(angle) * radius
  );
}
treeGeo.setAttribute("position", new THREE.Float32BufferAttribute(treePos, 3));
const tree = new THREE.Points(
  treeGeo,
  new THREE.PointsMaterial({ color: 0xaadfff, size: 0.8 })
);
scene.add(tree);

/* é¡¶éƒ¨æ˜Ÿæ˜Ÿ */
const topStar = new THREE.Mesh(
  new THREE.SphereGeometry(1.3, 16, 16),
  new THREE.MeshBasicMaterial({ color: 0xff7777 })
);
topStar.position.y = 22;
scene.add(topStar);

/* ğŸ’– çˆ±å¿ƒç²’å­ */
const hearts = [];
const heartGeo = new THREE.SphereGeometry(0.6, 8, 8);
const heartMat = new THREE.MeshBasicMaterial({ color: 0xff6699 });

for (let i = 0; i < 40; i++) {
  const heart = new THREE.Mesh(heartGeo, heartMat);
  resetHeart(heart);
  scene.add(heart);
  hearts.push(heart);
}

function resetHeart(h) {
  h.position.set(
    (Math.random() - 0.5) * 10,
    Math.random() * 30 - 10,
    (Math.random() - 0.5) * 10
  );
  h.speed = Math.random() * 0.05 + 0.02;
}

/* åŠ¨ç”» */
function animate() {
  requestAnimationFrame(animate);
  tree.rotation.y += 0.002;
  stars.rotation.y += 0.0004;

  hearts.forEach(h => {
    h.position.y += h.speed;
    if (h.position.y > 30) resetHeart(h);
  });

  renderer.render(scene, camera);
}
animate();

/* è‡ªé€‚åº” */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
