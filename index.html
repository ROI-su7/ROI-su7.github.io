<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Doctor Strange Portal Interaction</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #video-container { 
            position: absolute; top: 20px; right: 20px; 
            width: 180px; height: 135px; border-radius: 10px; 
            overflow: hidden; border: 2px solid rgba(255,165,0,0.3); 
            transform: scaleX(-1);
        }
        .instructions {
            position: absolute; bottom: 30px; left: 50%; 
            transform: translateX(-50%); color: #ff9800;
            text-align: center; pointer-events: none;
            text-shadow: 0 0 10px rgba(0,0,0,1);
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    <div id="video-container"><video id="input-video" style="width:100%; height:100%; object-fit: cover;"></video></div>
    
    <div class="instructions">
        握拳：关闭传送门 | 五指张开并旋转：开启传送门<br>
        伸出食指与中指：触发粒子扰动
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        let scene, camera, renderer, particles, geometry;
        const PARTICLE_COUNT = 12000;
        let portalState = { visible: false, rotation: 0, perturbation: 0, size: 1 };
        
        // 初始化颜色：奇异博士传送门经典的橙黄色
        const portalColor = new THREE.Color(0xff6a00);

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 20;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const sizes = new Float32Array(PARTICLE_COUNT);
            const randomness = new Float32Array(PARTICLE_COUNT);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // 初始位置设为 0
                positions[i * 3] = 0;
                positions[i * 3 + 1] = 0;
                positions[i * 3 + 2] = 0;
                sizes[i] = Math.random() * 2;
                randomness[i] = Math.random();
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 0.15,
                color: portalColor,
                transparent: true,
                opacity: 0,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // 核心：计算传送门圆环坐标
        function updatePortalGeometry() {
            const positions = geometry.attributes.position.array;
            const time = Date.now() * 0.005;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const angle = (i / PARTICLE_COUNT) * Math.PI * 2 + time * 0.2;
                const radius = 6 + (Math.random() - 0.5) * 1.5; // 圆环厚度
                
                // 基础圆环位置
                let x = Math.cos(angle) * radius;
                let y = Math.sin(angle) * radius;
                let z = (Math.random() - 0.5) * 1.0;

                // 如果食指中指伸出，增加扰动 (Perturbation)
                if (portalState.perturbation > 0.5) {
                    x += Math.sin(time + i) * 0.5;
                    y += Math.cos(time + i) * 0.5;
                    z += Math.tan(time * 0.1) * 0.2;
                }

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
            }
            geometry.attributes.position.needsUpdate = true;
        }

        function initHands() {
            const videoElement = document.getElementById('input-video');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({ maxNumHands: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
            
            hands.onResults((results) => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    
                    // 1. 检测手指是否全部张开 (比较指尖和指根距离)
                    const isFist = lm[8].y > lm[6].y && lm[12].y > lm[10].y && lm[16].y > lm[14].y && lm[20].y > lm[18].y;
                    
                    // 2. 检测食指和中指是否单独伸出 (用于扰动)
                    const isPeace = lm[8].y < lm[6].y && lm[12].y < lm[10].y && lm[16].y > lm[14].y;

                    // 3. 计算手掌旋转角度 (利用大拇指 4 到小拇指 20 的向量)
                    const angle = Math.atan2(lm[20].y - lm[4].y, lm[20].x - lm[4].x);

                    // 状态更新
                    if (!isFist) {
                        portalState.visible = true;
                        particles.material.opacity = THREE.MathUtils.lerp(particles.material.opacity, 1.0, 0.1);
                        particles.rotation.z = angle; // 传送门随手旋转
                        portalState.perturbation = isPeace ? 1.0 : 0.0;
                    } else {
                        particles.material.opacity = THREE.MathUtils.lerp(particles.material.opacity, 0.0, 0.1);
                        portalState.perturbation = 0;
                    }

                    // 4. 传送门中心跟随手掌
                    const centerX = (lm[9].x - 0.5) * -40; // 映射到场景坐标
                    const centerY = (lm[9].y - 0.5) * -30;
                    particles.position.set(centerX, centerY, 0);

                } else {
                    particles.material.opacity = THREE.MathUtils.lerp(particles.material.opacity, 0.0, 0.1);
                }
            });

            const cameraPipe = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480
            });
            cameraPipe.start();
        }

        function animate() {
            requestAnimationFrame(animate);
            if (particles.material.opacity > 0.01) {
                updatePortalGeometry();
            }
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        initThree();
        initHands();
        animate();
    </script>
</body>
</html>









