<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>奇异博士传送门 - 最终修复版</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        #video-container { 
            position: absolute; top: 20px; right: 20px; 
            width: 160px; height: 120px; border-radius: 8px; 
            overflow: hidden; border: 2px solid #ff9800; 
            transform: scaleX(-1); background: #000;
        }
        .instructions {
            position: absolute; bottom: 40px; left: 50%; 
            transform: translateX(-50%); color: #ff9800;
            text-align: center; pointer-events: none;
            background: rgba(0,0,0,0.6); padding: 10px 20px; border-radius: 20px;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    <div id="video-container"><video id="input-video"></video></div>
    
    <div class="instructions">
        <b>传送门控制指南</b><br>
        握拳：关闭 | 张开五指：开启 | 伸出食指中指：魔法扰动
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        let scene, camera, renderer, particles, geometry;
        const PARTICLE_COUNT = 10000;
        let handVisible = false;
        let isPerturbated = false;

        // 生成发光火花纹理
        function createSparkTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 160, 0, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 80, 0, 0.3)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 25;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x050505);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            geometry = new THREE.BufferGeometry();
            const pos = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            
            for(let i=0; i<PARTICLE_COUNT; i++) {
                pos[i*3] = pos[i*3+1] = pos[i*3+2] = 0;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));

            const material = new THREE.PointsMaterial({
                size: 0.5,
                map: createSparkTexture(),
                transparent: true,
                opacity: 0, // 初始透明
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                vertexColors: false,
                color: 0xffaa00
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function updatePortal(time) {
            const positions = geometry.attributes.position.array;
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // 基础环形算法
                const angle = (i / PARTICLE_COUNT) * Math.PI * 2 + time * 0.5;
                const innerRadius = 7;
                // 模拟火花四溅：半径随机扰动
                const r = innerRadius + Math.random() * 2.5; 
                
                let x = Math.cos(angle) * r;
                let y = Math.sin(angle) * r;
                let z = (Math.random() - 0.5) * 1.5;

                // 魔法扰动逻辑
                if (isPerturbated) {
                    const noise = Math.sin(i * 0.1 + time * 5) * 1.2;
                    x += noise;
                    y += noise;
                }

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
            }
            geometry.attributes.position.needsUpdate = true;
        }

        function initHands() {
            const videoElement = document.getElementById('input-video');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.6
            });

            hands.onResults((results) => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    handVisible = true;

                    // 判断是否握拳 (指尖位置低于指根位置)
                    const isFist = lm[8].y > lm[6].y && lm[12].y > lm[10].y;
                    // 判断食指中指 (剪刀手)
                    isPerturbated = (lm[8].y < lm[6].y && lm[12].y < lm[10].y && lm[16].y > lm[14].y);

                    // 显隐平滑过渡
                    if (!isFist) {
                        particles.material.opacity = Math.min(particles.material.opacity + 0.1, 1);
                    } else {
                        particles.material.opacity = Math.max(particles.material.opacity - 0.1, 0);
                    }

                    // 传送门中心跟随
                    const x = (lm[9].x - 0.5) * -40;
                    const y = (lm[9].y - 0.5) * -30;
                    particles.position.lerp(new THREE.Vector3(x, y, 0), 0.2);
                    
                    // 旋转跟随
                    const angle = Math.atan2(lm[20].y - lm[4].y, lm[20].x - lm[4].x);
                    particles.rotation.z = angle;

                } else {
                    particles.material.opacity = Math.max(particles.material.opacity - 0.05, 0);
                }
            });

            const camera = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480
            });
            camera.start();
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;
            
            if (particles.material.opacity > 0) {
                updatePortal(time);
            }
            
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        initThree();
        initHands();
        animate();
    </script>
</body>
</html>










