<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Magic Portal Debug Version</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: #ff9800; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        /* 调试面板 */
        #debug-info { 
            position: absolute; top: 10px; left: 10px; 
            background: rgba(0,0,0,0.8); padding: 10px; 
            font-size: 12px; z-index: 100; pointer-events: none;
            border: 1px solid #ff9800;
        }
        #video-container { 
            position: absolute; top: 10px; right: 10px; 
            width: 120px; height: 90px; border: 1px solid #555; 
            transform: scaleX(-1); z-index: 100;
        }
    </style>
</head>
<body>

    <div id="debug-info">
        系统状态：<span id="status">加载中...</span><br>
        手势检测：<span id="hand-status">未检测到</span>
    </div>
    <div id="canvas-container"></div>
    <div id="video-container">
        <video id="input-video" playsinline muted autoplay style="width:100%; height:100%; object-fit: cover;"></video>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        const statusEl = document.getElementById('status');
        const handEl = document.getElementById('hand-status');
        
        let scene, camera, renderer, particles, geometry;
        const PARTICLE_COUNT = 8000;
        let isPerturbated = false;

        // 1. 基础场景初始化
        function initThree() {
            try {
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.z = 20;

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x0a0a0a);
                document.getElementById('canvas-container').appendChild(renderer.domElement);

                geometry = new THREE.BufferGeometry();
                const pos = new Float32Array(PARTICLE_COUNT * 3);
                for(let i=0; i<PARTICLE_COUNT*3; i++) pos[i] = (Math.random()-0.5) * 2;
                
                geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                const mat = new THREE.PointsMaterial({
                    size: 0.15,
                    color: 0xff6600,
                    transparent: true,
                    opacity: 0.5, // 初始可见，防止全黑误导
                    blending: THREE.AdditiveBlending
                });

                particles = new THREE.Points(geometry, mat);
                scene.add(particles);
                statusEl.innerText = "渲染引擎就绪，等待摄像头...";
            } catch (e) {
                statusEl.innerText = "渲染错误: " + e.message;
            }
        }

        // 2. 传送门形状逻辑
        function updatePortal(time) {
            const positions = geometry.attributes.position.array;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const angle = (i / PARTICLE_COUNT) * Math.PI * 2 + time * 0.5;
                const r = 6 + Math.random() * 2; 
                positions[i*3] = Math.cos(angle) * r;
                positions[i*3+1] = Math.sin(angle) * r;
                positions[i*3+2] = isPerturbated ? Math.sin(time*10 + i)*2 : (Math.random()-0.5);
            }
            geometry.attributes.position.needsUpdate = true;
        }

        // 3. 手势与摄像头
        function initHands() {
            const videoElement = document.getElementById('input-video');
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults((results) => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    handEl.innerText = "✋ 已锁定";
                    const lm = results.multiHandLandmarks[0];
                    
                    // 逻辑：张开手 = 开启，握拳 = 关闭
                    const isFist = lm[8].y > lm[6].y; 
                    isPerturbated = (lm[8].y < lm[6].y && lm[12].y < lm[10].y && lm[16].y > lm[14].y);

                    particles.material.opacity = isFist ? 0.1 : 1.0;
                    
                    const x = (lm[9].x - 0.5) * -30;
                    const y = (lm[9].y - 0.5) * -20;
                    particles.position.set(x, y, 0);
                    particles.rotation.z = Math.atan2(lm[20].y - lm[4].y, lm[20].x - lm[4].x);
                } else {
                    handEl.innerText = "未检测到手";
                }
            });

            const cameraHelper = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640, height: 480
            });

            cameraHelper.start()
                .then(() => statusEl.innerText = "运行中 (若画面仍黑请尝试刷新)")
                .catch(err => statusEl.innerText = "摄像头失败: " + err);
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePortal(performance.now() * 0.001);
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        initThree();
        initHands();
        animate();
    </script>
</body>
</html>











